//*
Test para probar la Fase de Comprobacion de Tipos

COMPROBACION: El compilador del alumno debe detectar todos los errores indicados en los comentarios.

ADVERTENCIA: Hay algunos errores que producen otros errores derivados.

Por ejemplo:

	print juan + anton;	// suma de dos estructuras 

Lo anterior produce el error de que se estan sumando dos expresiones de tipos no simples y ademas
puede producir el error de que la expresion a imprimir tampoco es de tipo simple (al no quedar
un tipo simple asociado a la suma al no haberse podido calcular su tipo).
Estos errores derivados son normales y no es necesario intentar suprimirlos. 

NOTA: Es posible que el alumno deba adaptar ligeramente la sintaxis del lenguaje si no coincide
con la del lenguaje que le corresponde.
*//

class
	Prueba_type_checking;

	global
		deftuple Persona as
			edad : INTEGER;
			meses : [12] INTEGER;
		end

		juan : Persona;
		anton : Persona;

	create
		inicio;

	feature g : Persona is	/* Error: Retorno de tipo no simple
		do
		end

	feature f (a : [10] INTEGER) is	/* Los parametros deben de ser tipos primitivos
		do
			return 25;	/* El return no debe tener expresion en funciones void
		end

	feature h : INTEGER is
		do
			return 5.6;	/* Tipo de retorno no coincide
		end

	feature j (a : INTEGER, b : DOUBLE) : DOUBLE is
		do
			h(2);	/* Numero de argumentos incorrecto
			return; /* Debe haber un valor de retorno
		end

	feature inicio is
		local
		i : INTEGER;
		f : DOUBLE;
		v : [10]INTEGER;

		do
			if 2.5 then end /* La condicion debe ser de tipo entero
			if i then end
			
			from
			until juan; /* La condicion debe ser de tipo entero
			loop end	
			from
			until not i;
			loop end	
			
			5 := 6; /* Valor de la izquierda no modificable
			i := f; /* Valores de distinto tipo
			juan := anton; /* Valor de la izquierda debe ser simple

			read juan;	/* Debe ser un tipo simple
			read 35;	/* Debe ser modificable
			read i;
			
			print juan; /* Debe ser tipo simple
			print f / 2.5;
			
			j(12, 12.5);
			j(12, 12); 		/* Tipo de los parametros no coincide
			j(12);			/* Numero de argumentos no coincide
			j(12, 12.5, 4); /* Numero de argumentos no coincide
			
			print inicio();	/* No tiene tipo de retorno
			print j(12, 12.5);
			print j(12, 12); 		/* Tipo de los parametros no coincide
			print j(12);			/* Numero de argumentos no coincide
			print j(12, 12.5, 4); 	/* Numero de argumentos no coincide

			print juan + anton;	/* Deben ser tipos simples
			print 2.5 * 2;		/* Deben ser del mismo tipo
			print i - 2;

			print 2.5 and f;	/* Deben ser tipo entero
			print 2 or i;
			
			print juan > anton;	/* Deben ser tipos simples
			print 2.5 < 2;		/* Deben ser del mismo tipo
			print i = 2;
			
			print to<INTEGER>(2.5) + i;
			print to<Persona>(2.5);		/* El cast solo puede ser usado con tipos simples
			print to<INTEGER>(juan);	/* Expresiones de tipos simples
			print to<DOUBLE>(2.5);		/* Deben ser distintos tipos
			
			print juan[5];	/* Debe ser tipo array
			print 2[5];		/* Debe ser tipo array
			print v[5.0];	/* Debe ser indice entero
			print v[i+2];
			
			print juan.edad;
			print 5.edad;		/* Se requiere tipo struct
			print juan.nombre;	/* Campo no definido
		end
end

main
	inicio();
end